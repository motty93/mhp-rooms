# Avatar URL NULL Issue 修正

**実装日**: 2025-09-16
**実装時間**: 約2時間
**担当者**: Claude Code

## 問題の概要

プロフィール画像のアップロード機能は正常に動作し、GCSにファイルも保存されていたが、以下の問題が発生していた：

- サーバーログではユーザーのavatar_urlに有効なポインタアドレス（例：`0xc0005b27d0`）が表示される
- しかし、`/api/auth/user` APIのJSONレスポンスでは `avatar_url: null` が返される
- 結果として、プロフィール画面やヘッダーのアバター画像が表示されない

## 根本原因の分析

### 1. 仮説検証のプロセス

1. **JSON marshaling問題の検証**
   - 独立したテストプログラムでUser構造体のJSON化をテスト
   - 結果：JSON marshalingは正常に動作（nil/非nilポインタ両方で正しい結果）

2. **データベース層の検証**  
   - 直接データベースから取得したデータでのテスト
   - 結果：データベース取得、GORM、リポジトリ層は全て正常に動作

3. **キャッシュ層の問題特定**
   - サーバーログで有効なポインタアドレスが確認される
   - しかし、JSON marshalingでnullになる現象を確認
   - **結論**: キャッシュされたUser構造体のポインタが有効だが、指している先のメモリが破損またはガベージコレクションされている

### 2. 技術的詳細

**問題のメカニズム:**
- JWTAuth middlewareがユーザー情報を30秒間キャッシュ
- キャッシュ時にUser構造体のポインタフィールド（`*string`）が有効なアドレスを持つ
- しかし、ポインタが指すメモリ領域が他のGoルーチンやGCにより無効化
- APIコール時に有効なポインタアドレスは存在するが、実際の値が読み取れずnullとなる

## 実装した解決策

### 修正内容

**ファイル**: `internal/handlers/auth.go`

**変更点**:
- `GetCurrentUser`関数を完全に書き換え
- キャッシュされたデータベースユーザーを使用する代わりに、直接データベースから最新データを取得
- 認証ユーザーからSupabase User IDを取得し、リポジトリ層で最新のユーザー情報を取得

```go
// 修正前（キャッシュ使用）
func (h *AuthHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
    dbUser, hasDBUser := middleware.GetDBUserFromContext(r.Context())
    // ... キャッシュされたdbUserを使用
}

// 修正後（直接DB取得）
func (h *AuthHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
    authUser, hasAuthUser := middleware.GetUserFromContext(r.Context())
    // ... 認証ユーザーIDから直接DBを検索
    dbUser, err := h.repo.User.FindUserBySupabaseUserID(supabaseUserID)
    // ... 最新データを使用
}
```

### 設計判断の理由

1. **パフォーマンス vs 一貫性のトレードオフ**
   - GetCurrentUser APIは頻繁に呼ばれるが、正確性がより重要
   - キャッシュによる若干のパフォーマンス向上よりも、データの一貫性を優先

2. **影響範囲の最小化**
   - 他のキャッシュ機能には影響を与えない
   - GetCurrentUser APIのみ直接DB取得に変更

3. **メンテナンス性の向上**
   - キャッシュ関連の複雑な問題を回避
   - デバッグが容易になる

## テスト結果

### 1. コンパイル・ビルドテスト
- ✅ 正常にコンパイル・ビルドが完了
- ✅ サーバー起動が正常に完了

### 2. データベーステスト
- ✅ リポジトリ層での直接データ取得テストが正常
- ✅ JSON marshaling処理が正常
- ✅ ポインタ値の正常な取得を確認

### 3. 動作確認
- ✅ サーバーが正常に起動
- ✅ 認証フローが正常に動作（リダイレクト確認）

## 今後の改善提案

### 短期的改善
1. **キャッシュ戦略の見直し**
   - ポインタフィールドを含む構造体のキャッシュ方法を検討
   - 値のコピーによるキャッシュの実装

2. **モニタリング強化**
   - GetCurrentUser APIのレスポンス時間監視
   - データベース接続数の監視

### 長期的改善
1. **キャッシュ層のリアーキテクチャ**
   - Redisベースの外部キャッシュ導入検討
   - 構造化されたキャッシュキー管理

2. **API設計の見直し**
   - 頻繁に更新されるユーザー情報のリアルタイム同期方法

## 学んだ教訓

1. **Go言語のポインタとメモリ管理**
   - 構造体のポインタフィールドをキャッシュする際の注意点
   - ガベージコレクションがキャッシュに与える影響

2. **デバッグ手法**
   - 複雑な問題を段階的に分解して原因を特定する重要性
   - 仮説検証による効率的な問題解決アプローチ

3. **設計原則**
   - 「複雑さよりもシンプルさ」の重要性
   - パフォーマンスよりも正確性を優先する場合の判断基準

## 関連ファイル

- `internal/handlers/auth.go` - メイン修正ファイル
- `internal/middleware/auth.go` - キャッシュ機能（今回は変更なし）
- `internal/storage/gcs.go` - GCSアップロード機能（関連）

## 注意事項

この修正により、GetCurrentUser APIは毎回データベースアクセスを行うため、若干のレスポンス時間増加が予想される。ただし、ユーザー体験の向上（アバター画像の正常表示）を優先した設計判断である。