# ユーザークエリ最適化実装

**実装時間**: 約60分（調査・実装・検証含む）

## 概要

部屋一覧ページで大量のユーザー関連クエリが重複実行される問題を解決しました。ログインしたユーザーのリクエストごとに以下の重複クエリが発生していました：

- `FindUserBySupabaseUserID`が複数回実行
- `UpdateUser`が複数回実行
- ミドルウェアとSyncUserエンドポイントで同じ処理が重複

## 問題の原因

1. **ミドルウェアでの非同期ユーザー作成**: 
   - 各リクエストで`ensureUserExists`が非同期実行される
   - 既存ユーザーでもDB照会が毎回発生

2. **フロントエンドからの重複同期**:
   - 認証成功時に`/api/auth/sync`エンドポイントも呼び出される
   - 同様の処理が重複実行

3. **競合状態**:
   - 複数のリクエストが同時に来た場合、同じユーザーに対して複数のクエリが実行

## 実装した改善

### 1. ミドルウェアの最適化

**変更前**: 毎回非同期でユーザー作成処理を実行
```go
if j.repo != nil {
    go j.ensureUserExists(user)
}
```

**変更後**: ユーザー情報をコンテキストに同期的にロード
```go
// DBからユーザー情報を取得してコンテキストに保存（同期的に実行）
if j.repo != nil {
    if dbUser := j.loadDBUser(user); dbUser != nil {
        ctx = context.WithValue(ctx, DBUserContextKey, dbUser)
    }
}
```

### 2. コンテキストベースのキャッシュ

新しいコンテキストキーを追加：
```go
const (
    UserContextKey contextKey = "user"
    DBUserContextKey contextKey = "dbUser"  // 新規追加
)
```

ヘルパー関数を追加：
```go
// GetDBUserFromContext はコンテキストからDB上のユーザー情報を取得
func GetDBUserFromContext(ctx context.Context) (*models.User, bool) {
    dbUser, ok := ctx.Value(DBUserContextKey).(*models.User)
    return dbUser, ok
}
```

### 3. ハンドラーの改善

**SyncUser**と**UpdatePSNId**ハンドラーを修正：

- コンテキストからDBユーザー情報を優先取得
- 新規作成は`EnsureUserExists`メソッドに統一
- 重複クエリを削減

```go
// コンテキストからDBユーザー情報を取得
dbUser, hasDBUser := middleware.GetDBUserFromContext(r.Context())

if !hasDBUser || dbUser == nil {
    // 新規作成処理
} else {
    // 既存ユーザー更新処理
}
```

## パフォーマンス改善効果

### 改善前のクエリパターン
```
1. ミドルウェア: FindUserBySupabaseUserID (非同期)
2. SyncUser: FindUserBySupabaseUserID
3. SyncUser: UpdateUser
4. ミドルウェア: UpdateUser (非同期、競合状態)
```

### 改善後のクエリパターン
```
1. ミドルウェア: FindUserBySupabaseUserID (1回のみ、同期的)
2. SyncUser: コンテキストから取得（DBクエリなし）
3. SyncUser: UpdateUser (必要時のみ)
```

**削減効果**:
- ユーザー取得クエリ: 複数回 → 1回
- ユーザー更新クエリ: 複数回 → 必要時のみ
- 競合状態: 解消

## 技術的なポイント

1. **同期的な処理**: 非同期処理による競合状態を回避
2. **リクエストスコープキャッシュ**: コンテキストを活用したクエリ削減
3. **処理の一元化**: ユーザー作成ロジックを`EnsureUserExists`に統一
4. **後方互換性**: 既存のAPIインターフェースを維持

## テスト結果

- ビルドエラーなし
- 既存機能の動作に影響なし
- パフォーマンス改善により、DBへの負荷軽減を実現

## 今後の改善可能性

1. **Redis キャッシュ**: ユーザー情報をRedisでキャッシュ
2. **バッチ処理**: 複数ユーザーの一括処理
3. **メトリクス監視**: クエリ数の継続的な監視

この最適化により、特にトラフィックが多い環境でのデータベース負荷が大幅に軽減されることが期待されます。